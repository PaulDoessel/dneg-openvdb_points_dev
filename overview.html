<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenVDBPoints: OpenVDB Points Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">OpenVDB Points</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="overview">OpenVDB Points Overview </a></h1><h2><a class="anchor" id="Contents">
Contents</a></h2>
<ul>
<li><a class="el" href="overview.html#secOverview">Introduction</a></li>
<li><a class="el" href="overview.html#secCompression">Compression</a></li>
<li><a class="el" href="overview.html#secLocality">Locality</a></li>
<li><a class="el" href="overview.html#secAttributes">Attributes</a><ul>
<li><a class="el" href="overview.html#secTypedAttributeArray">TypedAttributeArray</a></li>
<li><a class="el" href="overview.html#secAttributeHandle">AttributeHandle</a></li>
<li><a class="el" href="overview.html#secAttributePerformance">TypedAttributeArray vs AttributeHandle</a></li>
<li><a class="el" href="overview.html#secAttributeSet">AttributeSet and AttributeDescriptor</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secPointTree">The Point Tree</a><ul>
<li><a class="el" href="overview.html#secPointIndexTree">Point Index Tree</a></li>
<li><a class="el" href="overview.html#secPointDataTree">Point Data Tree</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secSparsity">Voxel Values</a><ul>
<li><a class="el" href="overview.html#secBackground">Background and Tile Values</a></li>
<li><a class="el" href="overview.html#secActiveValues">Active Values</a></li>
<li><a class="el" href="overview.html#secIndexIterators">Index Iterators</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secSpaceAndTrans">Voxel Space, Index Space, World Space</a></li>
</ul>
<h2><a class="anchor" id="secOverview">
Introduction</a></h2>
<p>This document is a high-level summary of the terminology and basic components of the <b>OpenVDB</b> <b>Points</b> extension library. The key concept is that storing point data in spatial data structures offers opportunities for <b>improved</b> <b>performance</b> and <b>greater</b> <b>compression</b> compared with linear arrays. OpenVDB provides the spatial data structure and it is highly recommended for the reader to start with the <a href="http://www.openvdb.org/documentation/doxygen/overview.html">OpenVDB documentation</a> to get a thorough understanding of the library on which this extension is built.</p>
<h2><a class="anchor" id="secCompression">
Compression</a></h2>
<p>A key motivation behind the library is to increase data compression and thus reduce the memory and disk space requirements of the point set.</p>
<p>There are three types of compression used in this library to store point attribute data - (1) <b>value</b> <b>compression</b> where the codec is selected specifically based on the intent of the data, (2) <b>uniform</b> <b>value</b> <b>compression</b> where arrays of identical values can be collapsed down into a single value, (3) <b>stream</b> <b>compression</b> where the Blosc stream compressor can be used to pack and unpack streams of data using a fast, lossless compression codec.</p>
<p>Uniform value and stream compression are offered in other applications, notably Houdini, but with the case of stream compression, predominantly used to reduce disk storage.</p>
<p>Value compression is a relatively underused style of compression for point data and is most evident in using quantization for point positions. The floating-point representation has been around for many years and has developed into an extremely good general solution to the problem of capturing different orders of magnitude with a fixed number of digits. However, point sets typically contain positional data that is fairly uniform and within a small relative range, so floating-point is not the ideal representation for this type of data.</p>
<p>Instead, positional data can be retained in a quantized, fixed-point representation and can use OpenVDB for the spatial organisation for highly compact storage.</p>
<p>In addition, other attributes such as velocity can benefit from value compression. For example, a unit vector scheme can compress a 3 x float vector (12 bytes) into just 2 bytes.</p>
<h2><a class="anchor" id="secLocality">
Locality</a></h2>
<p>Data compression isn't the only area to benefit from a spatially organised data set. Due to the effects of L1 and L2 caching in modern CPUs, improved cache locality through storing point data close in memory to their neighbors can bring about a big improvement in performance.</p>
<p>A number of point rasterization gather-style tests that compared spatially organised data with linear data dereferenced using a spatial acceleration structure consistently resulted in a performance improvement of between 2x and 3x.</p>
<h2><a class="anchor" id="secAttributes">
Attributes</a></h2>
<p>Attribute storage is a key feature of OpenVDB Points and is provided as a completely standalone feature within the library to allow for use outside of OpenVDB grids.</p>
<h3><a class="anchor" id="secTypedAttributeArray">
TypedAttributeArray</a></h3>
<p>The TypedAttributeArray stores array data with a specified value type and compression codec, which are part of the template signature.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> Codec&gt;
<span class="keyword">class </span>TypedAttributeArray: <span class="keyword">public</span> AttributeArray
</pre></div><p>The underlying AttributeArray from which the TypedAttributeArray derives is not templated and can be used for all non-typed operations such as serialization.</p>
<h3><a class="anchor" id="secAttributeHandle">
AttributeHandle</a></h3>
<p>AttributeHandle and AttributeWriteHandle classes provide access to the array data without requiring knowledge of the codec. This is important as it allows users to add their own attribute compression schemes without requiring any modification to existing code.</p>
<p>Another reason for using the AttributeHandle mechanism is to allow data to be packed and unpacked efficiently using stream compression. When compressed with a stream compression scheme, the AttributeHandle unpacks attribute data into a local (uncompressed) buffer on access and discards this temporary data once the AttributeHandle goes out of scope. This has the benefit of retaining the stream compression during access which lowers the peak memory substantially. In addition, out-of-core and compression checks are not used once the handle is created improving performance.</p>
<p>Note that this feature is not available for AttributeWriteHandles as thread safety cannot otherwise be guaranteed.</p>
<h3><a class="anchor" id="secAttributePerformance">
TypedAttributeArray vs AttributeHandle</a></h3>
<p>One key benefit of AttributeHandles is that they ensure the data being accessed has been uncompressed and is in-core on creation of the handle to avoid the need to perform these checks when the data is being accessed and modified for extra performance. Performance of AttributeHandles have been compared against TypedAttributeArrays and std::vectors and have been shown to be faster in practice. Profile tests have been provided amongst the unit tests that can be used to verify this.</p>
<h3><a class="anchor" id="secAttributeSet">
AttributeSet and AttributeDescriptor</a></h3>
<p>The AttributeSet stores a collection of attribute arrays along with an AttributeDescriptor that tracks the type of each of the attribute arrays.</p>
<p>In typical use cases, the AttributeDescriptor is shared amongst LeafNodes, however that isn't required.</p>
<h2><a class="anchor" id="secPointTree">
The Point Tree</a></h2>
<p>Although included in the main OpenVDB library, it is worth covering the PointIndexTree in addition to the PointDataTree provided within OpenVDB Points.</p>
<h3><a class="anchor" id="secPointIndexTree">
Point Index Tree</a></h3>
<p>The PointIndexTree is an acceleration structure in OpenVDB that stores in a new LeafNode an array of indices into a linear point array. This is very similar in principal to the PointDataTree except that the actual data is stored in the LeafNodes as opposed to merely indices to follow to retrieve the data from a linear array.</p>
<p>The PointIndexTree has this tree configuration:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> tree::Tree4&lt;PointIdx32, 5, 4, 3&gt;::Type PointIndexTree;
</pre></div><h3><a class="anchor" id="secPointDataTree">
Point Data Tree</a></h3>
<p>The PointDataTree has this tree configuration:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> tree::Tree4&lt;PointDataIdx32, 5, 4, 3&gt;::Type <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1tools.html#a2e5f0934cd92615fa5d0eb794233f4ed" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>;
</pre></div><p>Note that with both the PointIndexTree and the PointDataTree, the data type is actually a 32-bit unsigned integer, but it is provided in this form to distinguish it from other LeafNodes that store the same data type. None of the other components within the Tree or Grid hierarchy change. It is for this reason that many of the existing features of OpenVDB work out-of-the-box such as serialization.</p>
<h2><a class="anchor" id="secSparsity">
Voxel Values</a></h2>
<p>For the PointDataTree, the voxel values represent the end position in the linear attribute arrays attached to each LeafNode. Using the value of the previous voxel (zero for the first voxel), the offset for the start can be deduced.</p>
<h3><a class="anchor" id="secBackground">
Background and Tile Values</a></h3>
<p>There are three distinct ways of storing data in an OpenVDB tree: <b>voxel values</b>, <b>tile values</b>, and a <b>background value</b>. Unfortunately the background value and tile values make little sense for point data. While technically it would be valid to use a non-zero background value and tile value, this would simply mean that only the first voxel in the LeafNode contains points which is neither an efficient storage mechanism nor particularly common. For this reason, the LeafNode constructor may take a background value but it is internally overriden to be zero on construction.</p>
<h3><a class="anchor" id="secActiveValues">
Active Values</a></h3>
<p>Any voxel or tile can be classified as either <b>active</b> or <b>inactive</b>. The interpretation of this state is application-specific, however there are some conventions, such as using the active state to denote the narrow band in a levelset. For points, the most logical use of the active state is to mark a voxel as active if it contains points and inactive otherwise. This allows iteration over the points in a LeafNode to be accelerated to only iterate over voxels that contain points.</p>
<h3><a class="anchor" id="secIndexIterators">
Index Iterators</a></h3>
<p>There are three styles of index iterators - <b>IndexIter</b>, <b>ValueIndexIter</b>, <b>FilterIndexIter</b>. <b>IndexIter</b> is a basic start-to-end iterator. <b>ValueIndexIter</b> is an iterator that uses an underlying ValueOnIter/ValueOffIter/ValueAllIter to provide voxel filtering. The most common use case for this style is in performing gather-style rasterization where retrieving the points in all neighboring voxels is required. <b>FilterIndexIter</b> is an iterator that uses a custom filtering mechanism in addition to being based on an IndexIter or ValueIndexIter. The most common use case for this style is in filtering over indices that are a member of an attribute group.</p>
<p>There are also fast implementations to sum up the number times an iterator would need to step to reach termination.</p>
<h2><a class="anchor" id="secSpaceAndTrans">
Voxel Space, Index Space, World Space</a></h2>
<p>Points are stored in <b>voxel</b> <b>space</b>, meaning all point positions lie between (-0.5, -0.5, -0.5) and (0.5, 0.5, 0.5) with the center of the voxel being (0.0, 0.0, 0.0). The position of the point can be extracted in <b>index</b> <b>space</b> by adding the voxel space position to the ijk value of the voxel. The position of the point can be extracted in <b>world</b> <b>space</b> by using the grid transform to do an indexToWorld conversion. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 30 Mar 2016 for OpenVDBPoints by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
