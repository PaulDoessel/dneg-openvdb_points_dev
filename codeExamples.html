<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenVDBPoints: OpenVDB Points Cookbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">OpenVDB Points</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="codeExamples">OpenVDB Points Cookbook </a></h1><p>This section provides code snippets and some complete programs that illustrate how to use OpenVDB Points and how to perform common tasks.</p>
<h2><a class="anchor" id="Contents">
Contents</a></h2>
<ul>
<li><a class="el" href="codeExamples.html#sHelloWorld">"Hello, World" for OpenVDB Points</a><ul>
<li><a class="el" href="codeExamples.html#sCompilingHelloWorld">Compiling</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sPointCreation">Assemble a VDB Point Grid</a></li>
<li><a class="el" href="codeExamples.html#sPointConversion">Point Conversion</a></li>
</ul>
<h2><a class="anchor" id="sHelloWorld">
"Hello, World" for OpenVDB Points</a></h2>
<p>This is a very simple example showing how to convert a std::vector of point positions into a VDB Point Grid and write it out to disk: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;openvdb/openvdb.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb_points/openvdb.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointDataGrid_8h.html" title="Attribute-owned data structure for points. Point attributes are stored in leaf nodes...">openvdb_points/tools/PointDataGrid.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointConversion_8h.html" title="Convert existing points and attributes into VDB Point Data grids and attributes.">openvdb_points/tools/PointConversion.h</a>&gt;</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>openvdb::tools;

<span class="keywordtype">int</span> main()
{
    <span class="comment">// Initialize the OpenVDB and OpenVDB Points library.  This must be called at least</span>
    <span class="comment">// once per program and may safely be called multiple times.</span>
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::initialize</a>();
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::points::initialize</a>();

    <span class="comment">// Create some point positions</span>
    std::vector&lt;openvdb::Vec3f&gt; positions;

    positions.push_back(openvdb::Vec3f(1.2, 4.1, 0.5));
    positions.push_back(openvdb::Vec3f(0.9, 8.1, 3.2));
    positions.push_back(openvdb::Vec3f(-3.6, 1.3, 1.5));
    positions.push_back(openvdb::Vec3f(-3.8, 1.4, 1.51));
    positions.push_back(openvdb::Vec3f(-6.8, -9.1, -3.7));
    positions.push_back(openvdb::Vec3f(1.4, 40302.5, 9.5));

    <span class="comment">// Create a linear transform with voxel size of 10.0</span>
    <span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 10.0f;
    openvdb::math::Transform::Ptr transform = openvdb::math::Transform::createLinearTransform(voxelSize);

    <span class="comment">// Create the PointDataGrid, position attribute is mandatory</span>
    PointDataGrid::Ptr pointDataGrid = createPointDataGrid&lt;PointDataGrid&gt;(
                    positions, TypedAttributeArray&lt;openvdb::Vec3f&gt;::attributeType(), *transform);

    <span class="comment">// Output leaf nodes</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Leaf Nodes: &quot;</span> &lt;&lt; pointDataGrid-&gt;tree().leafCount() &lt;&lt; std::endl;

    <span class="comment">// Create an accessor and output point count</span>
    PointDataAccessor&lt;PointDataTree&gt; accessor(pointDataGrid-&gt;tree());
    std::cout &lt;&lt; <span class="stringliteral">&quot;Point Count: &quot;</span> &lt;&lt; accessor.totalPointCount() &lt;&lt; std::endl;

    <span class="comment">// Create a VDB file object.</span>
    openvdb::io::File file(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>);

    <span class="comment">// Add the grid pointer to a container.</span>
    openvdb::GridPtrVec grids;
    grids.push_back(pointDataGrid);

    <span class="comment">// Write out the contents of the container.</span>
    file.write(grids);
    file.close();
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Leaf Nodes: 3
Point Count: 6
</pre></div><h3><a class="anchor" id="sCompilingHelloWorld">
Compiling</a></h3>
<p>See the <code>Makefile</code> and <code>INSTALL</code> file included in this distribution for details on how to build and install the OpenVDB library. By default, installation is into the directory tree rooted at <code>/tmp/OpenVDB/</code>, but this can be changed either by editing the value of the <code>DESTDIR</code> variable in the makefile or by setting the desired value from the command line, as in the following example: </p>
<div class="fragment"><pre class="fragment">make install DESTDIR=/usr/local
</pre></div><p> Once OpenVDB and OpenVDB Points has been installed, the simplest way to compile a program like the &ldquo;Hello, World&rdquo; example above is to examine the commands that are used to build the <code>vdb_print</code> tool: </p>
<div class="fragment"><pre class="fragment">rm vdb_print
make verbose=yes vdb_print
</pre></div><p> and then replace &ldquo;<code>-o vdb_print</code>&rdquo; with, for example, &ldquo;<code>-o helloworld</code>&rdquo; and &ldquo;<code>cmd/openvdb_print/main.cc</code>&rdquo; with &ldquo;<code>helloworld.cc</code>&rdquo;.</p>
<h2><a class="anchor" id="sPointCreation">
Assemble a VDB Point Grid</a></h2>
<p>This example shows how to create a VDB Points grid with one leaf node and to insert a point per voxel with position only. OpenVDB supports both random access to voxels by coordinates and sequential access by means of iterators. This example illustrates both types of access: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;openvdb/openvdb.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb_points/openvdb.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointDataGrid_8h.html" title="Attribute-owned data structure for points. Point attributes are stored in leaf nodes...">openvdb_points/tools/PointDataGrid.h</a>&gt;</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>openvdb::tools;

<span class="keywordtype">int</span> main()
{
    <span class="comment">// Initialize the OpenVDB and OpenVDB Points library.  This must be called at least</span>
    <span class="comment">// once per program and may safely be called multiple times.</span>
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::initialize</a>();
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::points::initialize</a>();

    <span class="comment">// Create an empty point data grid</span>
    PointDataGrid::Ptr grid = PointDataGrid::create();

    <span class="comment">// Introduce a typedef for our position attribute (note no compression codec here)</span>
    <span class="keyword">typedef</span> TypedAttributeArray&lt;openvdb::Vec3f&gt; PositionAttribute;

    <span class="comment">// Create a list of names and attribute types (in this case, just position)</span>
    AttributeSet::Descriptor::NameAndTypeVec attributes;
    attributes.push_back(AttributeSet::Descriptor::NameAndType(<span class="stringliteral">&quot;P&quot;</span>, PositionAttribute::attributeType()));

    <span class="comment">// Create an AttributeSet Descriptor for this list</span>
    AttributeSet::Descriptor::Ptr descriptor = AttributeSet::Descriptor::create(attributes);

    <span class="comment">// Touch a leaf at the origin to create it and confirm just one leaf</span>
    PointDataTree::LeafNodeType* leaf = grid-&gt;tree().touchLeaf(openvdb::Coord(0, 0, 0));

    std::cout &lt;&lt; <span class="stringliteral">&quot;Leaf Count: &quot;</span> &lt;&lt; grid-&gt;tree().leafCount() &lt;&lt; std::endl;

    <span class="comment">// Decide how many points per voxel we want</span>

    <span class="keyword">const</span> <span class="keywordtype">int</span> pointsPerVoxel = 1;
    <span class="keyword">const</span> <span class="keywordtype">size_t</span> totalPoints = pointsPerVoxel * PointDataTree::LeafNodeType::NUM_VOXELS;

    <span class="comment">// Initialize sets up the AttributeSet on the leaf and sizes it</span>
    leaf-&gt;initializeAttributes(descriptor, <span class="comment">/*arrayLength = */</span> totalPoints);

    <span class="comment">// Values store the end offset of the attribute array for each voxel</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PointDataTree::LeafNodeType::NUM_VOXELS; i++) {
        <span class="keyword">const</span> uint arrayOffset = (i + 1) * pointsPerVoxel;
        leaf-&gt;setOffsetOn(i, arrayOffset);
    }

    <span class="comment">// Retrieve a write-able attribute handle for position</span>
    AttributeWriteHandle&lt;openvdb::Vec3f&gt;* attributeWriteHandle = leaf-&gt;attributeWriteHandle&lt;openvdb::Vec3f&gt;(<span class="stringliteral">&quot;P&quot;</span>);

    <span class="comment">// Set the point positions to be at the center of each voxel (range is -0.5 -&gt; 0.5)</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; totalPoints; i++) {
        attributeWriteHandle-&gt;set(i, openvdb::Vec3f(0.0, 0.0, 0.0));
    }

    <span class="comment">// Create an accessor which has some useful utilities for retrieving point data</span>
    PointDataAccessor&lt;PointDataTree&gt; accessor(grid-&gt;tree());

    <span class="comment">// Output the total number of points stored in our Point Grid</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Point Count: &quot;</span> &lt;&lt; accessor.totalPointCount() &lt;&lt; std::endl;

    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing random access:&quot;</span> &lt;&lt; std::endl;

    <span class="comment">// Retrieve a read-only attribute handle for position</span>
    AttributeHandle&lt;openvdb::Vec3f&gt;* attributeHandle = leaf-&gt;attributeHandle&lt;openvdb::Vec3f&gt;(<span class="stringliteral">&quot;P&quot;</span>);

    <span class="comment">// Create a co-ordinate to perform the look-up and voxel position in index space</span>
    <span class="keyword">const</span> openvdb::Coord ijk(4, 0, 0);
    <span class="keyword">const</span> openvdb::Vec3f voxelIndexSpace = ijk.asVec3d();

    <span class="comment">// Retrieve the grid transform</span>
    <span class="keyword">const</span> openvdb::math::Transform&amp; transform = grid-&gt;transform();

    <span class="comment">// Create a PointDataIndex for accessing the co-ordinate (4, 0, 0)</span>
    PointDataAccessor&lt;PointDataTree&gt;::PointDataIndex index = accessor.get(ijk);

    <span class="comment">// Iterate over all the points in the (4, 0, 0) voxel</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = index.first; i &lt; index.second; i++) {
        <span class="comment">// Retrieve point position in voxel space</span>
        <span class="keyword">const</span> openvdb::Vec3f&amp; pointVoxelSpace = attributeHandle-&gt;get(i);

        <span class="comment">// Compute point position in index space</span>
        <span class="keyword">const</span> openvdb::Vec3f pointIndexSpace = pointVoxelSpace + voxelIndexSpace;

        <span class="comment">// Compute point position in world space using grid transform</span>
        <span class="keyword">const</span> openvdb::Vec3f pointWorldSpace = transform.indexToWorld(pointIndexSpace);

        <span class="comment">// Output the world space point position</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Point Position[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; pointWorldSpace &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing sequential access:&quot;</span> &lt;&lt; std::endl;

    <span class="comment">// Now iterate over all points within all leaves</span>
    <span class="keywordflow">for</span> (PointDataTree::LeafCIter iter = grid-&gt;tree().cbeginLeaf(); iter; ++iter) {
        AttributeHandle&lt;openvdb::Vec3f&gt;* attributeHandle = iter-&gt;attributeHandle&lt;openvdb::Vec3f&gt;(<span class="stringliteral">&quot;P&quot;</span>);

        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; totalPoints; i++) {
            <span class="comment">/*point position = */</span> attributeHandle-&gt;get(i);

            <span class="comment">// see example above for how to compute the world space point position</span>
        }
    }
}
</pre></div><p> Output: </p>
<div class="fragment"><pre class="fragment">Leaf Count: 1
Point Count: 512
Testing random access:
Point Position[256]: [4, 0, 0]
Testing sequential access:
</pre></div><h2><a class="anchor" id="sPointConversion">
Point Conversion</a></h2>
<p>This is a more comprehensive conversion example that demonstrates how to convert points with multiple attributes: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;openvdb/openvdb.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb_points/openvdb.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointDataGrid_8h.html" title="Attribute-owned data structure for points. Point attributes are stored in leaf nodes...">openvdb_points/tools/PointDataGrid.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointAttribute_8h.html" title="Add attributes to a VDB Point Grid.">openvdb_points/tools/PointAttribute.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="PointConversion_8h.html" title="Convert existing points and attributes into VDB Point Data grids and attributes.">openvdb_points/tools/PointConversion.h</a>&gt;</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>openvdb::tools;

<span class="keywordtype">int</span> main()
{
    <span class="comment">// Initialize the OpenVDB and OpenVDB Points library.  This must be called at least</span>
    <span class="comment">// once per program and may safely be called multiple times.</span>
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::initialize</a>();
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1points.html#a355ab7f9579290cbd31168e45c89d5ae" title="Global registration of basic types.">openvdb::points::initialize</a>();

    <span class="comment">// Create some point positions</span>
    std::vector&lt;openvdb::Vec3f&gt; positions;

    positions.push_back(openvdb::Vec3f(1.2, 4.1, 0.5));
    positions.push_back(openvdb::Vec3f(0.9, 100.1, 3.2));

    <span class="comment">// Create a linear transform with voxel size of 10.0</span>
    <span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 10.0f;
    openvdb::math::Transform::Ptr transform = openvdb::math::Transform::createLinearTransform(voxelSize);

    std::cout &lt;&lt; <span class="stringliteral">&quot;Creating VDB Points grid&quot;</span> &lt;&lt; std::endl;

    <span class="comment">// Create a PointPartitioner-compatible point list using the std::vector wrapper provided</span>
    <span class="keyword">const</span> PointAttributeVector&lt;openvdb::Vec3f&gt; pointList(positions);

    <span class="comment">// Create a PointIndexGrid from the point positions, this extra step is only required</span>
    <span class="comment">// as we&apos;re adding extra attributes beyond just position and wish to re-use the index ordering</span>
    PointIndexGrid::Ptr pointIndexGrid = createPointIndexGrid&lt;PointIndexGrid&gt;(pointList, *transform);

    <span class="comment">// Create the PointDataGrid, position attribute is mandatory</span>
    PointDataGrid::Ptr pointDataGrid = createPointDataGrid&lt;PointDataGrid&gt;(*pointIndexGrid,
                    pointList, TypedAttributeArray&lt;openvdb::Vec3f&gt;::attributeType(), *transform);

    <span class="comment">// Retrieve an iterator pointing to the first leaf node</span>
    PointDataTree::LeafCIter iter = pointDataGrid-&gt;tree().cbeginLeaf();

    <span class="comment">// No leaf nodes means no points, best to always check before dereferencing</span>
    <span class="keywordflow">if</span> (!iter)  std::cout &lt;&lt; <span class="stringliteral">&quot;No Points&quot;</span> &lt;&lt; std::endl;

    <span class="comment">// Output the number of attributes stored in this leaf node</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Attributes: &quot;</span> &lt;&lt; iter-&gt;attributeSet().descriptor().size() &lt;&lt; std::endl;

    std::cout &lt;&lt; <span class="stringliteral">&quot;Adding pscale attribute&quot;</span> &lt;&lt; std::endl;

    <span class="comment">// Add a new pscale attribute</span>
    AttributeSet::Util::NameAndType pscaleAttribute(<span class="stringliteral">&quot;pscale&quot;</span>, TypedAttributeArray&lt;float&gt;::attributeType());

    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1tools.html#a6c159add727760312df3eb6d5bb60789" title="Appends a new attribute to the VDB tree.">appendAttribute</a>(pointDataGrid-&gt;tree(), pscaleAttribute);

    <span class="comment">// Create some point pscale values</span>
    std::vector&lt;float&gt; pscales;

    pscales.push_back(1.1f);
    pscales.push_back(0.9f);

    <span class="comment">// Create a point attribute list using the std::vector wrapper provided</span>
    <span class="keyword">const</span> PointAttributeVector&lt;float&gt; pscalesList(pscales);

    <span class="comment">// Now populate the pscale attribute according to these values</span>
    <a class="code" href="namespaceopenvdb_1_1v3__1__0_1_1tools.html#a77eb403529730a7c910c96b7b60d11f0" title="Stores point attribute data in an existing PointDataGrid attribute.">populateAttribute</a>(pointDataGrid-&gt;tree(), pointIndexGrid-&gt;tree(), <span class="stringliteral">&quot;pscale&quot;</span>, pscalesList);

    <span class="comment">// Output the number of attributes stored in this leaf node</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Attributes: &quot;</span> &lt;&lt; iter-&gt;attributeSet().descriptor().size() &lt;&lt; std::endl;
}
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 25 Sep 2015 for OpenVDBPoints by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
